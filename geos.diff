Index: source/index/strtree/AbstractSTRtree.cpp
===================================================================
--- source/index/strtree/AbstractSTRtree.cpp	(revision 2610)
+++ source/index/strtree/AbstractSTRtree.cpp	(working copy)
@@ -288,6 +288,20 @@
 	}
 }
 
+void
+AbstractSTRtree::iterate(ItemVisitor& visitor)
+{
+    for (BoundableList::const_iterator i=itemBoundables->begin(), e=itemBoundables->end();
+			i!=e; i++)
+	{
+		const Boundable* boundable = *i;
+		if (const ItemBoundable *ib=dynamic_cast<const ItemBoundable *>(boundable))
+		{
+			visitor.visitItem(ib->getItem());
+		}
+        }
+}
+
 /*protected*/
 std::auto_ptr<BoundableList>
 AbstractSTRtree::boundablesAtLevel(int level)
Index: source/headers/geos/index/strtree/AbstractSTRtree.h
===================================================================
--- source/headers/geos/index/strtree/AbstractSTRtree.h	(revision 2610)
+++ source/headers/geos/index/strtree/AbstractSTRtree.h	(working copy)
@@ -202,6 +202,7 @@
 	}
 
 	virtual AbstractNode* getRoot() {
+                assert(built);
 		return root;
 	}
 
@@ -219,8 +220,6 @@
 		return matches;
 	}
 #endif
-
-
 	///  Also builds the tree, if necessary.
 	void query(const void* searchBounds, ItemVisitor& visitor);
 
@@ -281,6 +280,13 @@
 	virtual void query(const void* searchBounds, const AbstractNode* node, std::vector<void*>* matches);
 
 	/**
+         * Iterate over all items added thus far.  Explicitly does not build
+         * the tree.
+         */
+	void iterate(ItemVisitor& visitor);
+
+
+	/**
 	 * @param level -1 to get items
 	 */
 	virtual void boundablesAtLevel(int level, AbstractNode* top,
Index: swig/ruby/ruby.i
===================================================================
--- swig/ruby/ruby.i	(revision 2610)
+++ swig/ruby/ruby.i	(working copy)
@@ -104,3 +104,73 @@
     free((void*) $1);
   }
 }
+
+// GeosPreparedGeometry
+// Use predicates to make the ruby code nicer  - so disjoint?
+%rename("contains_properly?") GeosPreparedGeometry::containsProperly;
+%predicate GeosPreparedGeometry::contains;
+%predicate GeosPreparedGeometry::intersects;
+%predicate GeosPreparedGeometry::covers;
+
+// GeosSTRtree
+
+%rename("each") GeosSTRtree::iterate;
+
+%typemap(in) GeosIndexItem
+{
+    $1 = (GeosIndexItem) $input;
+}
+
+/* accumulator will be blissfully unused because
+ * Ruby supports closures, more or less */
+%typemap(in,numinputs=0) (GeosIndexItem accumulator)
+{
+    $1 = (GeosIndexItem) Qnil;
+}
+
+/* typecheck GeosIndexItem and make sure it's really a VALUE */
+%typemap(typecheck) GeosIndexItem
+{
+    $1 = (TYPE($input) & T_MASK) ? 1 : 0;
+}
+
+/* always call the provided block as the query callback */
+%typemap(in,numinputs=0) GeosQueryCallback
+{
+    $1 = GeosSTRtree_query_callback;
+}
+
+%typemap(typecheck) GeosQueryCallback
+{
+    /* SWIG throws a warning if we don't do this */
+    $1 = 1;
+}
+
+%{
+    /* this callback yields the data item to the block */
+    static void GeosSTRtree_query_callback (void *data, void *nothing) {
+        if (rb_block_given_p()) {
+            rb_yield((VALUE) data);
+        }
+    }
+%}
+
+/* assuming that GeosIndexItems are all VALUEs (since this gets tested
+ * on typemap(in)), mark them during the mark phase of GC to hang on to them */
+%{
+    static void GeosSTRtree_mark_item (void *data, void *nothing)
+    {
+        if ((VALUE) data != Qnil) {
+            rb_gc_mark((VALUE)data);
+        }
+    }
+
+    static void mark_GeosSTRtree(void *self)
+    {
+        GEOSSTRtree *tree = (GEOSSTRtree *) self;
+        GEOSSTRtree_iterate(tree, GeosSTRtree_mark_item, NULL);
+    }
+%}
+
+%markfunc GeosSTRtree "mark_GeosSTRtree";
+
Index: swig/geos.i.in
===================================================================
--- swig/geos.i.in	(revision 2610)
+++ swig/geos.i.in	(working copy)
@@ -950,6 +950,126 @@
 
 %clear GeosCoordinateSequence *s;
 
+// === Prepared Geometry ===
+
+%{
+typedef void GeosPreparedGeometry;
+%}
+
+%rename (Prepared) GeosPreparedGeometry;
+class GeosPreparedGeometry
+{
+public:
+%extend
+{
+    GeosPreparedGeometry(const GeosGeometry *source)
+    {
+        const GEOSPreparedGeometry *prep = GEOSPrepare((const GEOSGeometry *)source);
+        if(prep == NULL)
+            throw std::runtime_error(message);
+        return (GeosPreparedGeometry *) prep;
+    }
+
+    ~GeosPreparedGeometry()
+    {
+        GEOSPreparedGeometry *prep = (GEOSPreparedGeometry *) self;
+        return GEOSPreparedGeom_destroy(prep);
+    }
+
+    bool contains (const GeosGeometry* other)
+    {
+        GEOSPreparedGeometry *prep = (GEOSPreparedGeometry *) self;
+        GEOSGeom otherGeom = (GEOSGeom) other;
+        return checkBoolResult(GEOSPreparedContains(prep, otherGeom));
+    }
+
+    bool containsProperly(const GeosGeometry* other)
+    {
+        GEOSPreparedGeometry *prep = (GEOSPreparedGeometry *) self;
+        GEOSGeom otherGeom = (GEOSGeom) other;
+        return checkBoolResult(GEOSPreparedContainsProperly(prep, otherGeom));
+    }
+
+    bool covers (const GeosGeometry* other)
+    {
+        GEOSPreparedGeometry *prep = (GEOSPreparedGeometry *) self;
+        GEOSGeom otherGeom = (GEOSGeom) other;
+        return checkBoolResult(GEOSPreparedCovers(prep, otherGeom));
+    }
+
+    bool intersects (const GeosGeometry* other)
+    {
+        GEOSPreparedGeometry *prep = (GEOSPreparedGeometry *) self;
+        GEOSGeom otherGeom = (GEOSGeom) other;
+        return checkBoolResult(GEOSPreparedIntersects(prep, otherGeom));
+    }
+}
+};
+
+// === STRtree ===
+
+%{
+typedef void GeosSTRtree;
+/* GeosIndexItem typedef'd here so it can be %typemap(typecheck)'d
+   as a native object by each language specially */
+typedef void *GeosIndexItem;
+typedef GEOSQueryCallback GeosQueryCallback;
+%}
+
+%rename (STRtree) GeosSTRtree;
+class GeosSTRtree
+{
+public:
+%extend
+{
+    %typemap(default) int nodeCapacity {
+     $1 = 10;
+    };
+    GeosSTRtree(int nodeCapacity)
+    {
+        GEOSSTRtree *tree = GEOSSTRtree_create(nodeCapacity);
+        if(tree == NULL)
+            throw std::runtime_error(message);
+        return (GeosSTRtree *) tree;
+    }
+
+    ~GeosSTRtree()
+    {
+        GEOSSTRtree *tree = (GEOSSTRtree *) self;
+        return GEOSSTRtree_destroy(tree);
+    }
+
+    void insert (const GeosGeometry* g, GeosIndexItem item)
+    {
+        GEOSSTRtree *tree = (GEOSSTRtree *) self;
+        const GEOSGeometry *geom = (const GEOSGeometry *) g;
+        GEOSSTRtree_insert(tree, geom, item);
+    }
+
+    void remove (const GeosGeometry* g, GeosIndexItem item)
+    {
+        GEOSSTRtree *tree = (GEOSSTRtree *) self;
+        const GEOSGeometry *geom = (const GEOSGeometry *) g;
+        GEOSSTRtree_remove(tree, geom, item);
+    }
+
+    void query (const GeosGeometry* g, GeosQueryCallback callback,
+                GeosIndexItem accumulator)
+    {
+        GEOSSTRtree *tree = (GEOSSTRtree *) self;
+        const GEOSGeometry *geom = (const GEOSGeometry *) g;
+        GEOSSTRtree_query(tree, geom, callback, accumulator);
+    }
+
+    void iterate (GeosQueryCallback callback, GeosIndexItem accumulator)
+    {
+        GEOSSTRtree *tree = (GEOSSTRtree *) self;
+        GEOSSTRtree_iterate(tree, callback, accumulator);
+    }
+}
+};
+
+
 // === Input/Output ===
 
 /* This typemap allows the scripting language to pass in buffers
Index: capi/geos_c.cpp
===================================================================
--- capi/geos_c.cpp	(revision 2610)
+++ capi/geos_c.cpp	(working copy)
@@ -16,6 +16,7 @@
  ***********************************************************************/
 
 #include <geos/geom/prep/PreparedGeometryFactory.h> 
+#include <geos/index/strtree/STRtree.h>
 #include <geos/io/WKTReader.h>
 #include <geos/io/WKBReader.h>
 #include <geos/io/WKTWriter.h>
@@ -29,6 +30,7 @@
 #define GEOSGeometry geos::geom::Geometry
 #define GEOSPreparedGeometry geos::geom::prep::PreparedGeometry
 #define GEOSCoordSequence geos::geom::CoordinateSequence
+#define GEOSSTRtree geos::index::strtree::STRtree
 #define GEOSWKTReader_t geos::io::WKTReader
 #define GEOSWKTWriter_t geos::io::WKTWriter
 #define GEOSWKBReader_t geos::io::WKBReader
@@ -64,11 +66,12 @@
 using geos::io::WKBWriter;
 using geos::io::CLocalizer;
 
+using geos::index::strtree::STRtree;
+
 using geos::operation::overlay::OverlayOp;
 using geos::operation::overlay::overlayOp;
 using geos::operation::geounion::CascadedPolygonUnion;
 
-
 typedef std::auto_ptr<Geometry> GeomAutoPtr;
 
 //## GLOBALS ################################################
@@ -835,4 +838,49 @@
     return GEOSPreparedIntersects_r( handle, pg1, g2 );
 }
 
+STRtree *
+GEOSSTRtree_create (size_t nodeCapacity)
+{
+    return GEOSSTRtree_create_r( handle, nodeCapacity );
+}
+
+void
+GEOSSTRtree_insert (geos::index::strtree::STRtree *tree,
+                    const geos::geom::Geometry *g,
+                    void *item)
+{
+    GEOSSTRtree_insert_r( handle, tree, g, item );
+}
+
+void
+GEOSSTRtree_query (geos::index::strtree::STRtree *tree,
+                   const geos::geom::Geometry *g, 
+                   GEOSQueryCallback cb,
+                   void *userdata)
+{
+    GEOSSTRtree_query_r( handle, tree, g, cb, userdata );
+}
+
+void 
+GEOSSTRtree_iterate(geos::index::strtree::STRtree *tree,
+                    GEOSQueryCallback callback,
+                    void *userdata)
+{
+    GEOSSTRtree_iterate_r( handle, tree, callback, userdata );
+}
+
+char
+GEOSSTRtree_remove (geos::index::strtree::STRtree *tree,
+                    const geos::geom::Geometry *g,
+                    void *item)
+{
+    return GEOSSTRtree_remove_r( handle, tree, g, item );
+}
+
+void
+GEOSSTRtree_destroy (geos::index::strtree::STRtree *tree)
+{
+    GEOSSTRtree_destroy_r( handle, tree );
+}
+
 } /* extern "C" */
Index: capi/geos_ts_c.cpp
===================================================================
--- capi/geos_ts_c.cpp	(revision 2610)
+++ capi/geos_ts_c.cpp	(working copy)
@@ -31,6 +31,9 @@
 #include <geos/geom/GeometryFactory.h> 
 #include <geos/geom/CoordinateSequenceFactory.h> 
 #include <geos/geom/IntersectionMatrix.h> 
+#include <geos/geom/Envelope.h> 
+#include <geos/index/strtree/STRtree.h> 
+#include <geos/index/ItemVisitor.h>
 #include <geos/io/WKTReader.h>
 #include <geos/io/WKBReader.h>
 #include <geos/io/WKTWriter.h>
@@ -66,6 +69,7 @@
 #define GEOSGeometry geos::geom::Geometry
 #define GEOSPreparedGeometry geos::geom::prep::PreparedGeometry
 #define GEOSCoordSequence geos::geom::CoordinateSequence
+#define GEOSSTRtree geos::index::strtree::STRtree
 #define GEOSWKTReader_t geos::io::WKTReader
 #define GEOSWKTWriter_t geos::io::WKTWriter
 #define GEOSWKBReader_t geos::io::WKBReader
@@ -4022,5 +4026,275 @@
     return 2;
 }
 
+//-----------------------------------------------------------------
+// STRtree
+//-----------------------------------------------------------------
+
+
+class CAPI_ItemVisitor : public geos::index::ItemVisitor {
+    GEOSQueryCallback callback;
+    void *userdata;
+  public:
+    CAPI_ItemVisitor (GEOSQueryCallback cb, void *ud)
+        : ItemVisitor(), callback(cb), userdata(ud) {};
+    void visitItem (void *item) { callback(item, userdata); };
+};
+
+geos::index::strtree::STRtree *
+GEOSSTRtree_create_r(GEOSContextHandle_t extHandle,
+                                  size_t nodeCapacity)
+{
+    if ( 0 == extHandle )
+    {
+        return 0;
+    }
+
+    GEOSContextHandleInternal_t *handle = 0;
+    handle = reinterpret_cast<GEOSContextHandleInternal_t*>(extHandle);
+    if ( 0 == handle->initialized )
+    {
+        return 0;
+    }
+
+    geos::index::strtree::STRtree *tree = 0;
+
+    try
+    {
+        tree = new geos::index::strtree::STRtree(nodeCapacity);
+    }
+    catch (const std::exception &e)
+    {
+        handle->ERROR_MESSAGE("%s", e.what());
+    }
+    catch (...)
+    {
+        handle->ERROR_MESSAGE("Unknown exception thrown");
+    }
+    
+    return tree;
+}
+
+void
+GEOSSTRtree_insert_r(GEOSContextHandle_t extHandle,
+                     geos::index::strtree::STRtree *tree,
+                     const geos::geom::Geometry *g,
+                     void *item)
+{
+    GEOSContextHandleInternal_t *handle = 0;
+    assert(tree != 0);
+    assert(g != 0);
+
+    try
+    {
+        tree->insert(g->getEnvelopeInternal(), item);
+    }
+    catch (const std::exception &e)
+    {
+        if ( 0 == extHandle )
+        {
+            return;
+        }
+
+        handle = reinterpret_cast<GEOSContextHandleInternal_t*>(extHandle);
+        if ( 0 == handle->initialized )
+        {
+            return;
+        }
+
+        handle->ERROR_MESSAGE("%s", e.what());
+    }
+    catch (...)
+    {
+        if ( 0 == extHandle )
+        {
+            return;
+        }
+
+        handle = reinterpret_cast<GEOSContextHandleInternal_t*>(extHandle);
+        if ( 0 == handle->initialized )
+        {
+            return;
+        }
+
+        handle->ERROR_MESSAGE("Unknown exception thrown");
+    }
+}
+
+void 
+GEOSSTRtree_query_r(GEOSContextHandle_t extHandle,
+                    geos::index::strtree::STRtree *tree,
+                    const geos::geom::Geometry *g,
+                    GEOSQueryCallback callback,
+                    void *userdata)
+{
+    GEOSContextHandleInternal_t *handle = 0;
+    assert(tree != 0);
+    assert(g != 0);
+    assert(callback != 0);
+
+    try
+    {
+        CAPI_ItemVisitor visitor(callback, userdata);
+        tree->query(g->getEnvelopeInternal(), visitor);
+    }
+    catch (const std::exception &e)
+    {
+        if ( 0 == extHandle )
+        {
+            return;
+        }
+
+        handle = reinterpret_cast<GEOSContextHandleInternal_t*>(extHandle);
+        if ( 0 == handle->initialized )
+        {
+            return;
+        }
+
+        handle->ERROR_MESSAGE("%s", e.what());
+    }
+    catch (...)
+    {
+        if ( 0 == extHandle )
+        {
+            return;
+        }
+
+        handle = reinterpret_cast<GEOSContextHandleInternal_t*>(extHandle);
+        if ( 0 == handle->initialized )
+        {
+            return;
+        }
+
+        handle->ERROR_MESSAGE("Unknown exception thrown");
+    }
+}
+
+void 
+GEOSSTRtree_iterate_r(GEOSContextHandle_t extHandle,
+                    geos::index::strtree::STRtree *tree,
+                    GEOSQueryCallback callback,
+                    void *userdata)
+{
+    GEOSContextHandleInternal_t *handle = 0;
+    assert(tree != 0);
+    assert(callback != 0);
+
+    try
+    {
+        CAPI_ItemVisitor visitor(callback, userdata);
+        tree->iterate(visitor);
+    }
+    catch (const std::exception &e)
+    {
+        if ( 0 == extHandle )
+        {
+            return;
+        }
+
+        handle = reinterpret_cast<GEOSContextHandleInternal_t*>(extHandle);
+        if ( 0 == handle->initialized )
+        {
+            return;
+        }
+
+        handle->ERROR_MESSAGE("%s", e.what());
+    }
+    catch (...)
+    {
+        if ( 0 == extHandle )
+        {
+            return;
+        }
+
+        handle = reinterpret_cast<GEOSContextHandleInternal_t*>(extHandle);
+        if ( 0 == handle->initialized )
+        {
+            return;
+        }
+
+        handle->ERROR_MESSAGE("Unknown exception thrown");
+    }
+}
+
+char
+GEOSSTRtree_remove_r(GEOSContextHandle_t extHandle,
+                     geos::index::strtree::STRtree *tree,
+                     const geos::geom::Geometry *g,
+                     void *item)
+{
+    assert(0 != tree);
+    assert(0 != g);
+
+    if ( 0 == extHandle )
+    {
+        return 2;
+    }
+
+    GEOSContextHandleInternal_t *handle = 0;
+    handle = reinterpret_cast<GEOSContextHandleInternal_t*>(extHandle);
+    if ( 0 == handle->initialized )
+    {
+        return 2;
+    }
+
+    try 
+    {
+        bool result = tree->remove(g->getEnvelopeInternal(), item);
+        return result;
+    }
+    catch (const std::exception &e)
+    {
+        handle->ERROR_MESSAGE("%s", e.what());
+    }
+    catch (...)
+    {
+        handle->ERROR_MESSAGE("Unknown exception thrown");
+    }
+    
+    return 2;
+}
+
+void
+GEOSSTRtree_destroy_r(GEOSContextHandle_t extHandle,
+                      geos::index::strtree::STRtree *tree)
+{
+    GEOSContextHandleInternal_t *handle = 0;
+
+    try
+    {
+        delete tree;
+    }
+    catch (const std::exception &e)
+    {
+        if ( 0 == extHandle )
+        {
+            return;
+        }
+
+        handle = reinterpret_cast<GEOSContextHandleInternal_t*>(extHandle);
+        if ( 0 == handle->initialized )
+        {
+            return;
+        }
+
+        handle->ERROR_MESSAGE("%s", e.what());
+    }
+    catch (...)
+    {
+        if ( 0 == extHandle )
+        {
+            return;
+        }
+
+        handle = reinterpret_cast<GEOSContextHandleInternal_t*>(extHandle);
+        if ( 0 == handle->initialized )
+        {
+            return;
+        }
+
+        handle->ERROR_MESSAGE("Unknown exception thrown");
+    }
+}
+
 } /* extern "C" */
 
Index: capi/geos_c.h.in
===================================================================
--- capi/geos_c.h.in	(revision 2610)
+++ capi/geos_c.h.in	(working copy)
@@ -100,6 +100,7 @@
 typedef struct GEOSGeom_t GEOSGeometry;
 typedef struct GEOSPrepGeom_t GEOSPreparedGeometry;
 typedef struct GEOSCoordSeq_t GEOSCoordSequence;
+typedef struct GEOSSTRtree_t GEOSSTRtree;
 #endif
 
 /* Those are compatibility definitions for source compatibility
@@ -132,6 +133,8 @@
 
 typedef struct GEOSContextHandle_HS *GEOSContextHandle_t;
 
+typedef void (*GEOSQueryCallback)(void *item, void *userdata);
+
 /************************************************************************
  *
  * Initialization, cleanup, version
@@ -576,6 +579,57 @@
 
 /************************************************************************
  *
+ *  STRtree functions
+ *
+ ***********************************************************************/
+
+/* 
+ * GEOSGeometry ownership is retained by caller
+ */
+
+extern GEOSSTRtree GEOS_DLL *GEOSSTRtree_create(size_t nodeCapacity);
+extern void GEOS_DLL GEOSSTRtree_insert(GEOSSTRtree *tree,
+                                        const GEOSGeometry *g,
+                                        void *item);
+extern void GEOS_DLL GEOSSTRtree_query(GEOSSTRtree *tree,
+                                       const GEOSGeometry *g,
+                                       GEOSQueryCallback callback,
+                                       void *userdata);
+extern void GEOS_DLL GEOSSTRtree_iterate(GEOSSTRtree *tree,
+                                       GEOSQueryCallback callback,
+                                       void *userdata);
+extern char GEOS_DLL GEOSSTRtree_remove(GEOSSTRtree *tree,
+                                        const GEOSGeometry *g,
+                                        void *item);
+extern void GEOS_DLL GEOSSTRtree_destroy(GEOSSTRtree *tree);
+
+
+extern GEOSSTRtree GEOS_DLL *GEOSSTRtree_create_r(
+                                    GEOSContextHandle_t handle,
+                                    size_t nodeCapacity);
+extern void GEOS_DLL GEOSSTRtree_insert_r(GEOSContextHandle_t handle,
+                                          GEOSSTRtree *tree,
+                                          const GEOSGeometry *g,
+                                          void *item);
+extern void GEOS_DLL GEOSSTRtree_query_r(GEOSContextHandle_t handle,
+                                         GEOSSTRtree *tree,
+                                         const GEOSGeometry *g,
+                                         GEOSQueryCallback callback,
+                                         void *userdata);
+extern void GEOS_DLL GEOSSTRtree_iterate_r(GEOSContextHandle_t handle,
+                                       GEOSSTRtree *tree,
+                                       GEOSQueryCallback callback,
+                                       void *userdata);
+extern char GEOS_DLL GEOSSTRtree_remove_r(GEOSContextHandle_t handle,
+                                          GEOSSTRtree *tree,
+                                          const GEOSGeometry *g,
+                                          void *item);
+extern void GEOS_DLL GEOSSTRtree_destroy_r(GEOSContextHandle_t handle,
+                                           GEOSSTRtree *tree);
+
+
+/************************************************************************
+ *
  *  Unary predicate - return 2 on exception, 1 on true, 0 on false
  *
  ***********************************************************************/
