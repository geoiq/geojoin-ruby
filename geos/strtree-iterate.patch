Index: index/strtree/AbstractSTRtree.cpp
===================================================================
--- index/strtree/AbstractSTRtree.cpp	(revision 2610)
+++ index/strtree/AbstractSTRtree.cpp	(working copy)
@@ -288,6 +288,20 @@
 	}
 }
 
+void
+AbstractSTRtree::iterate(ItemVisitor& visitor)
+{
+    for (BoundableList::const_iterator i=itemBoundables->begin(), e=itemBoundables->end();
+			i!=e; i++)
+	{
+		const Boundable* boundable = *i;
+		if (const ItemBoundable *ib=dynamic_cast<const ItemBoundable *>(boundable))
+		{
+			visitor.visitItem(ib->getItem());
+		}
+        }
+}
+
 /*protected*/
 std::auto_ptr<BoundableList>
 AbstractSTRtree::boundablesAtLevel(int level)
Index: headers/geos/index/strtree/AbstractSTRtree.h
===================================================================
--- headers/geos/index/strtree/AbstractSTRtree.h	(revision 2610)
+++ headers/geos/index/strtree/AbstractSTRtree.h	(working copy)
@@ -202,6 +202,7 @@
 	}
 
 	virtual AbstractNode* getRoot() {
+                assert(built);
 		return root;
 	}
 
@@ -219,8 +220,6 @@
 		return matches;
 	}
 #endif
-
-
 	///  Also builds the tree, if necessary.
 	void query(const void* searchBounds, ItemVisitor& visitor);
 
@@ -281,6 +280,13 @@
 	virtual void query(const void* searchBounds, const AbstractNode* node, std::vector<void*>* matches);
 
 	/**
+         * Iterate over all items added thus far.  Explicitly does not build
+         * the tree.
+         */
+	void iterate(ItemVisitor& visitor);
+
+
+	/**
 	 * @param level -1 to get items
 	 */
 	virtual void boundablesAtLevel(int level, AbstractNode* top,
